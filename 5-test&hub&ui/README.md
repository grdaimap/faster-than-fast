## 软件测试

方面：功能性 安全性 可靠性 可用性 效率 可维护性 可移植性

开发模型：线性模型，渐进式模型，变换模型

瀑布模型把测试看成最后审查

快速应用开发（RAD）模型，良好的需求分析，项目范围明确，做了正确的事，正确地做了事，

规划与设计，计划和控制，分析和设计，设计测试用例，逻辑测试用例，具体测试用例，测试实现和执行，测试出口准则的评估和报告，测试结束活动。

测试基本原理：证存，不证不存，穷尽不可能，测试尽早开始，缺陷集群，杀虫剂悖论，依赖于测试内容，没有失效就是有用悖论

软件测试方法概述
静态测试和动态测试
黑盒测试和白盒测试

按照软件测试的策略和过程分类，软件测试可分为单元测试（Unit Testing），集成测试（Integration Testing），确认测试（Validation Testing），系统测试（System Testing）和验收测试（Verification Testing）。

等价类划分法 边界值分析法 决策表法 因果图法 

白盒测试通常的程序结构覆盖有：
语句覆盖；
判断覆盖；
条件覆盖；
判断/条件覆盖；
条件组合覆盖；
路径覆盖。

毫无疑问，稳定和可控的测试环境，可以使测试人员花费较少的时间就完成测试用例的执行，配置测试环境应该满足5个基本要素是：硬件、软件、网络环境、数据准备、测试工具。

虚拟机搭建测试环境。

测试用例，测试计划和文档。一个理想的测试计划应该体现以下几个特点：
在检测主要缺陷方面有一个好的选择；
提供绝大部分代码的覆盖率；
具有灵活性；
易于执行、回归和自动化；
定义要执行测试的种类；
测试文档明确说明期望的测试结果；
当缺陷被发现时提供缺陷核对；
明确定义测试目标；
明确定义测试策略；
明确定义测试通过标准；
没有测试冗余；
确认测试风险；
文档化确定测试的需求；
定义可交付的测试件。
1．需求阶段
（1）测试输入
需求计划（来自开发）。
（2）测试任务
制定验证和确认测试计划；
对需求进行分析和审核；
分析并设计基于需求的测试，构造对应的需求覆盖或追踪矩阵。
（3）可交付的文档
验收测试计划（针对需求设计）；
验收测试报告（针对需求设计）。
2．功能设计阶段
（1）测试输入
 功能设计规格说明（来自开发）。
（2）测试任务
功能设计验证和确认测试计划；
分析和审核功能设计规格说明；
可用性测试设计；
分析并设计基于功能的测试，构造对应的功能覆盖矩阵；
实施基于需求和基于功能的测试。
（3）可交付的文档
主确认测试计划；
验收测试计划（针对功能设计）；
验收测试报告（针对功能设计）。
3．详细设计阶段
（1）测试输入
详细设计规格说明（来自开发）。
（2）测试任务
详细设计验收测试计划；
分析和审核详细设计规格说明；
分析并设计基于内部的测试。
（3）可交付的文档
详细确认测试计划；
验收测试计划（针对详细设计）；
验收测试报告（针对详细设计）；
测试设计规格说明。
4．编码阶段
（1）测试输入
代码（来自开发）。
（2）测试任务
代码验收测试计划；
分析代码；
验证代码；
设计基于外部的测试；
设计基于内部的测试。
（3）可交付的文档 
测试用例规格说明；
需求覆盖或追踪矩阵；
功能覆盖矩阵；
测试步骤规格说明；
验收测试计划（针对代码）；
验收测试报告（针对代码）。
5．测试阶段
（1）测试输入
要测试的软件；
用户手册。
（2）测试任务
制定测试计划；
审查由开发部门进行的单元和集成测试；
进行功能测试；
进行系统测试；
审查用户手册。
（3）可交付的文档
测试记录；
测试事故报告；
测试总结报告。
6．运行/维护阶段
（1）测试输入
已确认的问题报告；
软件生命周期。软件生命周期是一个重复的过程。如果软件被修改了，开发和测试活动都要回归到与修改相对应的生命周期阶段。
（2）测试任务
监视验收测试；
为确认的问题开发新的测试用例；
对测试的有效性进行评估。
（3）可交付的文档
可升级的测试用例库。

软件自动化测试SoftTest。在使用SoftTest生成测试用例时，先将软件功能需求转化为文本形式的因果图，然后让SoftTest读入，SoftTest会根据因果图自动生成测试用例。在这个过程中，工具的使用者只需要完成由功能需求到因果图的转化，至于如何使用因果图来生成测试用例，则完全由Softtest完成。

①动态错误检测工具
动态错误检测工具，用来检查代码中类似于内存泄露、数组访问越界这样的程序错误。程序功能上的错误比较容易发现，因为它们很容易表现出来。但类似于内存泄露这样的问题，因为在程序短时间运行时不会表现出来，所以不易发现。遗留有这样问题的单元被集成到系统后，会使系统表现的极不稳定。
②性能分析工具
性能分析工具，记录被测程序的执行时间。小到一行代码、一个函数的运行时间，大到一个exe或dll文件的运行时间，性能分析工具都能清晰的记录下来。通过分析这些数据，能够帮助我们定位代码中的性能瓶颈。
③覆盖率统计工具
覆盖率统计工具，统计出我们当前执行的测试用例对代码的覆盖率。覆盖率统计工具提供的信息，可以帮助我们根据代码的覆盖情况，进一步完善测试用例，使所有的代码都被测试到，保证单元测试的全面性。有Compuware公司的NuMega DevPartner Studio，Rational 公司的Rational Suite Enterprise。功能测试自动化工具是软件测试工具中非常活跃的一类工具，现在发展的已经较为成熟，象Mercury Interactive公司的WinRunner，Rational公司的Robot，都是被广泛使用的功能测试自动化工具。
1．使用自动化测试的误区
自动化测试好处很多，但也有很多的局限，正因为一些人只认识到了自动化测试的优点，导致对它的期望太高，所以产生了很多执行自动化测试失败的例子。
（1）期望自动化测试能取代手工测试
某些情况下自动化测试并不适用，所以不能期望在所有的情况下都使用自动化测试来取代手工测试，测试主要还是要靠人工的。
（2）期望自动测试发现大量新缺陷
自动化测试只能发现已知的问题，所以不能期望自动化测试去发现更多新的缺陷，事实证明新缺陷越多，自动化测试失败的几率就越大。发现更多的新缺陷应该是手工测试的主要目的。
（3）工具本身不具有想象力
对于一些界面美观和易用性方面的测试，自动化测试工具无能为力。
（4） 只要使用自动化测试，就能缩短测试时间、提供测试效率
自动化测试的前期实现要花费更多的时间，相比创建和执行一个手工测试用例，要花费3~10倍的时间来开发、验证和文档化一个自动化测试用例。
（5）自动化测试工具使用了图形化界面，很容易上手，对人员的要求不高
简单的“录制/ 回放”方法并不能实现有效的、长期的自动化测试，测试人员还需要对脚本进行优化，这就需要测试人员具有设计、开发、测试、调试和编写代码的能力，最理想的候选人是既有编程经验，又有测试经验。测试过程中还需要安排专业人员对测试脚本库中的脚本进行维护。
2．不适合自动化测试的情况
自动化测试不是适合所有公司、所有项目的。列举如下：
（1） 定制型项目
为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。
（2）项目周期很短的项目
项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。
（3）业务规则复杂的对象
业务规则复杂的对象，有很多的逻辑关系、运算关系，工具就很难测试。
（4）美观、声音、易用性测试
人的感观方面的：界面的美观、声音的体验、易用性的测试，也只有人来测试。
3．自动化测试的缺点
（1）不能取代手工测试
（2）手工测试比自动测试发现的缺陷更多
（3）对测试质量的依赖性极大
（4）测试自动化不能提高有效性
（5）测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发
（6）工具本身并无想象力

面向对象的系统测试
8.3.1分析和设计模型测试技术
8.3.2 类测试技术
8.3.3 类层次结构测试技术
8.3.4 对象交互测试技术
TestSuite测试包类

10.1 软件质量保证与软件测试
10.2 软件测试管理和软件测试团队职责
10.3 ISO 9000标准
10.4 能力成熟度模型

CMM是一个行业标准模型，用于定义和评价软件公司开发过程的成熟度，一般将软件过程能力成熟度分为五个等级。
初始级（等级1）：软件过程的特点是无秩序的，偶尔甚至是混乱的。几乎没有什么过程是经过定义的，成功依赖于个人的努力。
可重复级（等级2）：已建立基本的项目管理过程去跟踪成本、进度和功能性。必要的过程纪律已经就位，使具有类似应用的项目，能重复以前的成功。
已定义级（等级3）：管理活动和工程活动两方面的软件过程均已文档化、标准化、并集成到组织的标准软件过程。全部项目均采用供开发和维护软件的组织标准软件过程中一个经批准的剪裁本。
已管理级（等级4）：已采集详细的有关软件过程和产品质量的度量。无论软件过程还是产品均得到定量了解和控制。
优化级（等级5）利用来自过程和来自新思想、新技术先导性试验的定量反馈信息，使持续过程改进成为可能。


## 结构化软件设计

爬

## UI和人机交互

爬











